{-# LANGUAGE RebindableSyntax, FlexibleContexts, PartialTypeSignatures,
    TypeApplications, DataKinds #-}

module Robot where

import Rearrange

import Prelude hiding (Monad(..))
import qualified Prelude as P
import Foreign.Ptr (Ptr)
import Foreign.C.Types (CInt)
import Data.IORef

foreign import ccall "inputCell" inputCell :: IO (Ptr CInt)
foreign import ccall "inputCell2" inputCell2 :: IO (Ptr CInt)
foreign import ccall "outputCell" outputCell :: IO (Ptr CInt)
foreign import ccall "outputCell2" outputCell2 :: IO (Ptr CInt)
foreign import ccall "outputCell3" outputCell3 :: IO (Ptr CInt)

-- The Robot example presented in the introduction, section 2 (called robot
-- in the paper), as well as in section 5 (called robot' in the paper).
-- prog is essentially robot and robot' combined.
-- This uses none of the helpers presented later in section 5, so requires full
-- type signatures (or many type annotations).

-- Type signature autogenerated by HLint.
prog :: HList
  '[Memory IO '( '[Cell Ptr "dist" CInt], '[Cell IORef "distVal" CInt]) (),
    Memory IO '( '[Cell IORef "distVal" CInt], '[Cell Ptr "motor" CInt]) (),
    Memory IO '( '[Cell Ptr "sensor" CInt], '[Cell IORef "normsensor" CInt])
      (),
    Memory IO '( '[Cell IORef "avg" [CInt], Cell IORef "normsensor" CInt],
         '[Cell Ptr "active" CInt, Cell IORef "avg" [CInt]]) ()]
prog = getDist :+: writeMotor :+: getLight :+: shouldAct :+: HNil

getEnv = toEnv $ toCell @"dist" inputCell :+:
    toCell @"motor" outputCell :+:
    toCell @"sensor" inputCell2 :+:
    toCell @"active" outputCell2 :+:
    toCell @"distVal" (newIORef (0 :: CInt)) :+:
    toCell @"normsensor" (newIORef (0 :: CInt)) :+:
    toCell @"avg" (newIORef ([] :: [CInt])) :+: HNil

average :: (Integral a, Num a) => [a] -> Int
average xs = fromIntegral (sum xs) `div` length xs

getDist :: Memory IO '( '[Cell Ptr "dist" CInt],
  '[Cell IORef "distVal" CInt]) ()
getDist = do
    x <- readCell @"dist"
    writeCell @"distVal" x

writeMotor :: Memory IO '(
  '[Cell IORef "distVal" CInt],
  '[Cell Ptr "motor" CInt]) ()
writeMotor = do
    x <- readCell @"distVal"
    writeCell @"motor" (-x)

getLight :: Memory IO '( '[Cell Ptr "sensor" CInt], '[Cell IORef "normsensor" CInt]) ()
getLight = do
    x <- readCell @"sensor"
    writeCell @"normsensor" x

shouldAct :: Memory IO '( '[Cell IORef "avg" [CInt], Cell IORef "normsensor" CInt],
  '[Cell Ptr "active" CInt, Cell IORef "avg" [CInt]]) ()
shouldAct = do
    x <- readCell @"normsensor"
    vals <- readCell @"avg"
    let readings = x : vals
    writeCell @"avg" readings
    let acts = if average readings > 100 then 0 else 1
    writeCell @"active" acts