{-# LANGUAGE RebindableSyntax, FlexibleContexts, PartialTypeSignatures,
    TypeApplications, DataKinds #-}

module Robot where

import Rearrange

import Prelude hiding (Monad(..))
import qualified Prelude as P
import Data.IORef

-- The Robot example presented in the introduction, section 2 (called robot
-- in the paper), as well as in section 5 (called robot' in the paper).
-- prog is essentially robot and robot' combined.
-- This uses none of the helpers presented later in section 5, so requires full
-- type signatures (or many type annotations).

-- Type signature autogenerated by HLint.
prog :: HList
  '[MIO '( '[IOCell "dist" Int], '[IOCell "distVal" Int]) (),
    MIO '( '[IOCell "distVal" Int], '[IOCell "motor" Int]) (),
    MIO '( '[IOCell "sensor" Int], '[IOCell "normsensor" Int])
      (),
    MIO '( '[IOCell "avg" [Int], IOCell "normsensor" Int],
         '[IOCell "active" Int, IOCell "avg" [Int]]) ()]
prog = getDist :+: writeMotor :+: getLight :+: shouldAct :+: HNil

getEnv = toEnv $ toCell @"dist" (newIORef (0 :: Int)) :+:
    toCell @"motor" (newIORef (0 :: Int)) :+:
    toCell @"sensor" (newIORef (0 :: Int)) :+:
    toCell @"active" (newIORef (0 :: Int)) :+:
    toCell @"distVal" (newIORef (0 :: Int)) :+:
    toCell @"normsensor" (newIORef (0 :: Int)) :+:
    toCell @"avg" (newIORef ([] :: [Int])) :+: HNil

average :: (Integral a, Num a) => [a] -> Int
average xs = fromIntegral (sum xs) `div` length xs

getDist :: MIO '( '[IOCell "dist" Int],
  '[IOCell "distVal" Int]) ()
getDist = do
    x <- readIOCell @"dist"
    writeIOCell @"distVal" x

writeMotor :: MIO '(
  '[IOCell "distVal" Int],
  '[IOCell "motor" Int]) ()
writeMotor = do
    x <- readIOCell @"distVal"
    writeIOCell @"motor" (-x)

getLight :: MIO '( '[IOCell "sensor" Int], '[IOCell "normsensor" Int]) ()
getLight = do
    x <- readIOCell @"sensor"
    writeIOCell @"normsensor" x

shouldAct :: MIO '( '[IOCell "avg" [Int], IOCell "normsensor" Int],
  '[IOCell "active" Int, IOCell "avg" [Int]]) ()
shouldAct = do
    x <- readIOCell @"normsensor"
    vals <- readIOCell @"avg"
    let readings = x : vals
    writeIOCell @"avg" readings
    let acts = if average readings > 100 then 0 else 1
    writeIOCell @"active" acts